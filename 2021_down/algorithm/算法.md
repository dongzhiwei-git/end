#####一、选择题题(共10个小题，每小题2分，共20分)
1.设序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}的最长公共子序列为Z={z1,z2,…,zk} ，则以下描述不正确的是（ ）
A、若xm=yn，则zk=xm=yn，且Zk-1是Xm-1和Yn-1的最长公共子序列
B、若xm≠yn且zk≠xm，则Z是xm-1和Y的最长公共子序列
C、若xm≠yn且zk≠yn，则Z是X和yn-1的最长公共子序列
D、若xm=yn，则zk≠xm≠yn，且Zk-1是Xm-1和Yn-1的最长公共子序列

2.以下哪种算法是以广度优先策略进行搜索的（b ）
A、回溯法		B、分支界限法		C、贪心算法		D、随机化算法

3.以下描述不正确的是（c ）
A、组成算法的每条指令是没有歧义的		
B、算法中每条指令的执行时间是有限的
C、在算法的循环结构中，指令的执行次数可以无限 
D、组成算法的每条指令是清晰的

4.Strassen矩阵乘法是利用（b ）实现的算法。
A、分治策略 B、动态规划法 C、贪心法 D、回溯法

5.矩阵A是一个p*q矩阵，B是q*r矩阵，则其乘积C=AB是一个（d ）矩阵
A、q*r		B、p*q C、p*q		D、p*r

6.以下描述正确的是（C ）
A、 每个递归函数不一定都要有非递归定义的初始值 
B、递归算法只能直接调用自身
C、**递归函数是由函数自身给出定义的 **
D、以上都不正确
**直接或简介地调用自身的算法称为递归算法。**
**用函数自身给出定义的函数称为递归函数。**
**每个递归函数都必修有非递归定义的初始值**


7.（d  ）是贪心算法与动态规划算法的共同点。
A、重叠子问题			    B、构造最优解	
C、贪心选择性质			D、最优子结构性质

8.分支限界法解01背包问题时，活结点表的组织形式是（A  ）。
A、优先队列						B、链表 			
C、栈							    D、数组

9.活动安排的贪心算法所需的计算时间为（ c  ）。
A、O（n2n）				  	 B、O（nlogn）	
C、O（n）                      D、O（2n）

10.以下增长最慢的是（a ）
A、log2n		B、nlog2n		C、n2		D、2n

11.用计算机解决问题的步骤一般为：（d）
①编写程序  ②设计算法  ③分析问题  ④调试程序 
A、①②③④			B、③④①②			
C、②③①④			D、③②①④

12.动态规划算法适用于解最优化问题，以下哪个不是动态规划法解决问题的步骤（ c）
A、找出最优解的性质，并刻画其结构特征
B、递归地定义最优值
C、以自顶向下的方式计算出最优值
D、根据计算最优值时得到的信息，构造最优解

+ **找出最优解的性质，并刻画其结构特征**
+ **递归地定义最优解**
+ **以自底向上地方式计算最优解**
+ **根据计算最优解得到的信息，构造最优解**

13.下列算法中通常以深度优先方式系统搜索问题解的是（ d   ）。
A、备忘录法      B、动态规划法    C、贪心法    D、回溯法

**备忘录法是动态规划的一种变形题。备忘录方法也用一个表格来保存已解决的子问题的答案，在下次需要解决此问题时，只要简单地查看该子问题的解答，而不必重新计算。与动态规划算法不同的是，备忘录方法的递归方式是自顶向下的，而动态规划算法则是自底向上递归的。因此，备忘录方法的控制结构与直接递归方法的控制结构相同，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题的重复求解。**

14.以下对于动态规划描述不正确的是（d ）
A、动态规划法与分治法类似，其基本思想也是将待求解问题分解成若干子问题
B、适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的
C、具体的动态规划算法多种多样，但是他们具有相同的填表格式
D、动态规划求解问题时和分治法一样，对子问题重复计算多次
**动态规划算法与分治法类似，其基本是将待求解问题分解成若干子问题，先求解子问题，再结合这些子问题的解得到原问题的解。与分治法不同的是，适合用动态规划求解的问题经分界得到的子问题往往不是相互独立的，在分治法求解时有些子问题被重复计算很多次，而动态规划是保存已解决的子问题的答案，在需要的时候使用，则可以避免大量的重复计算。**



15.矩阵A是一个p*q矩阵，B是q*r矩阵，则其乘积C=AB是一个（b ）矩阵
A、p*q		B、p*r		C、q*r		D、p*q

17.在对问题的解空间树进行搜索的方法中，一个活结点有多次机会成为活结点的是（  a  ）。
A、回溯法 				B、分支限界法
C、回溯法和分支限界法 	D、回溯法求解子集树问题

18.背包问题的贪心算法所需的计算时间为（ b  ）。
A、O（n2n）				  	 B、O（nlogn）	
C、O（n）                    D、O（2n）
**阿巴阿巴阿巴， 解析待定**

19.以下增长最快的是（a ）
A、n！	     B、nlog2n       C、n2	  	D、2n

20.备忘录方法是那种算法的变形。（ b  ）
A、分治法					B、动态规划法		
C、贪心法					D、分枝限界法
**看上面说的， 动态规划的一种变形**

21.用计算机解决问题的步骤一般为：（d）
①编写程序  ②设计算法  ③分析问题  ④调试程序 
A、①②③④			B、③④①②			
C、②③①④			D、③②①④

22.以下描述不正确的是（ c）
A、组成算法的每条指令是没有歧义的		
B、算法中每条指令的执行时间是有限的
C、在算法的循环结构中，指令的执行次数可以无限 
D、组成算法的每条指令是清晰的
+ **输入：有零个或多个由外部提供的量作为算法的输入**
+ **输出：算法产生至少一个量作为输出**
+ **确定性：组成算法的每条指令是清晰的，无歧义的**
+ **算法中的每条指令的执行次数是有限的，执行每条指令的时间也是有限的**

23.将一个难以直接解决的大问题，分解成一些规模较小的相同问题，以便各个击破。这属于（ b ）的解决方法。（ ）
A、动态规划	B、分治法	C、贪心算法		D、分支界限法

24.以下对于动态规划描述不正确的是（d ）
A、动态规划法与分治法类似，其基本思想也是将待求解问题分解成若干子问题
B、适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的
C、具体的动态规划算法多种多样，但是他们具有相同的填表格式
D、动态规划求解问题时和分治法一样，对子问题重复计算多次
**分治法的基本思想是将一个规模为n的问题分解为k个规模较小的子问题，这些子问题独立且与原问题相同**

25.有3个矩阵A维数是{10*100}，B维数是{100*5}，C维数是{5*50}，若按（（AB）C）计算，3个矩阵连乘积需要的乘法次数是（ a）
A、7500		B、75000		C、750		D、750000
**速算技巧是A(n,m) B(m,y) AB的乘法次数为n*m*y**

26.以下增长最快的是（  d）
A、log2n		B、nlog2n		C、n2		D、2n        

28.以下哪种算法是以深度优先策略进行搜索的（a ）
A、回溯法		B、分支界限法		C、贪心算法		D、随机化算法

29.动态规划算法适用于解最优化问题，以下哪个不是动态规划法解决问题的步骤（c ）
A、找出最优解的性质，并刻画其结构特征
B、递归地定义最优值
C、以自顶向下的方式计算出最优值
D、根据计算最优值时得到的信息，构造最优解

30.算法分析中，记号O表示（b ）
A.渐进下界
B.渐进上界
C.非紧上界
D.紧渐进界


31.下面关于算法的错误说法是（b ）
　  A、算法必须有输出 　  B、算法必须在计算机上用某种语言实现
　	C、算法不一定有输入   D、算法必须在有限步执行后能结束

32.以下描述不正确的是（ c）
　  A、组成算法的每条指令是没有歧义的		
　  B、算法中每条指令的执行时间是有限的
　  C、在算法的循环结构中，指令的执行次数可以无限 
　  D、组成算法的每条指令是清晰的

38.以下哪种算法是以广度优先策略进行搜索的（b ）
　  A、回溯法		B、分支界限法		C、贪心算法		D、随机化算法

39.以下增长最慢的是（a ）
　  A、log2n		B、nlog2n		C、n2		D、2n

41.二分搜索算法是利用（  a  ）实现的算法。
A、分治策略   B、动态规划法   C、贪心法    D、回溯法

44.0-1背包问题的回溯算法所需的计算时间为（c ）
    A、O（n2n） B、O（nlogn） C、O（2n） D、O（n）

45.下列不是动态规划算法基本步骤的是（ d  ）。
    A、找出最优解的性质   B、构造最优解   C、算出最优解   D、定义最优解

二、填空题(共10空，每空2分，共20分)
1.以广度优先搜索或以**最小耗费优先**方式搜索问题解的算法称为分支限界法。
**分支限界法常以广度有限或以最小耗费（最大收益）优先的方式搜索问题的解空间数**

2.算法的“确定性”指的是组成算法的每条指令是**清晰的，无歧义的**
+ **输入：有零个或多个由外部提供的量作为算法的输入**
+ **输出：算法产生至少一个量作为输出**
+ **确定性：组成算法的每条指令是清晰的，无歧义的**
+ **有限性：算法中的每条指令的执行次数是有限的，执行每条指令的时间也是有限的**

3.任何可用计算机求解的问题所需的**计算时间**都与其规模有关。

4.分支限界法主要有**队列式（FIFO)**分支限界法和优先队列分支限界法。

5.算法产生**至少一**个量作为输出。
6.算法的复杂性有**时间**复杂性和空间复杂性之分。
7.f(n)= 6×2n+10000×n2，f(n)的渐进上界是**2^n**。
8.一个直接或间接地调用自身的算法称为**递归**
9.最优子结构性质和**重叠子问题性质**是采用动态规划算法的两个基本要素。
10.回溯法搜索状态空间树是按照**深度优先遍历**的顺序
11.以广度优先搜索或以最小耗费方式搜索问题解的算法称为**分支限界法**。
12.算法的“确定性”指的是组成算法的每条**指令**是清晰的，无歧义的。
13.任何可用计算机求解的问题所需的时间都与其**数据规模**有关。
14.算法满足的性质：输入、输出、**确定性**、有限性。
15.分支限界法主要有队列式（FIFO）分支限界法和**优先队列式**分支限界法。
16.算法产生**至少一个**个量作为输出。
17.算法的复杂性有时间复杂性和**空间**复杂性之分。
18.f(n)= 300×3n+10000×n2，f(n)的渐进上界是**3^n**。
19.大整数乘积算法是用**分治法？？？？我也不确定**算法来设计的。 
20.递归函数有两个条件，一个是要直接或间接地调用自身，另一个是必须有**非递归定义的初始值**

21.递归与分治算法应满足条件：______与_______
22.按照渐近阶从低到高的顺序排列下列表达式：，结果为______。
23.回溯法中的解空间树结构通常有两种，分别是**子集树**、**排列树**。
24.算法满足的性质：**输入**、输出、**确定性**、有限性。
25.一个直接或间接地调用自身的算法称为**递归函数**，它有两个条件，一个是要直接或间接地调用自身，另一个是必须有**非递归定义的初始值**。
26.以广度优先或以最小耗费方式搜索问题解的算法称为**分支限界法**
27.**最优子结构性质**和**重叠子问题性质**是采用动态规划算法的两个基本要素。
28.回溯法中的解空间树结构通常有两种，分别是**子集树**、**排列树**。
29.按照渐近阶从低到高的顺序排列下列表达式： n2,logn,3n,45n,6,3n3/2,n! ，结果为______。
30.多项式的上界为**O(n^c)**。
31.算法满足的性质：输入、**输出**、确定性、**有限性**。
32.递归与分治算法应满足条件：最优子结构性质与**独立子问题性质**。
33.回溯法中的解空间树结构通常有两种，分别是子集树和**排列树**。
34.使用回溯法进行状态空间树裁剪分支时一般有两个标准：约束条件和目标函数的界，N皇后问题和0/1背包问题正好是两种不同的类型，其中同时使用约束条件和目标函数的界进行裁剪的是**0/1背包问题**，只使用约束条件进行裁剪的是**N皇后问题**。
35.f(n)=n^3+10*n+1000000的时间复杂度是**O（n^3）**。
36.算法的复杂性有 **时间**复杂性和空间复杂性之分。
37.程序是 **算法**用某种程序设计语言的具体实现。
38.算法的“确定性”指的是组成算法的每条 **指令**是清晰的，无歧义的。
39.从分治法的一般设计模式可以看出，用它设计出的程序一般是**递归算法**。
40.动态规划算法的两个基本要素是最优子结构性质和**重叠子问题**。
42.程序是**算法**用某种程序设计语言的具体实现。
43.算法的“确定性”指的是组成算法的每条**指令**是清晰的，无歧义的。
44.回溯法中的解空间树结构通常有两种，分别是**子集树**和排列树。
45.分治法的基本思想是首先将待求解问题分解成若干**相同的子问题**。
46.回溯法搜索解空间树时，常用的两种剪枝函数为约束函数和**约束边界**
47.动态规划算法的两个基本要素是**最优子结构性质**和重叠子问题 。
48.、解决0/1背包问题可以使用动态规划、回溯法，其中不需要排序的是**动态规划**，需要排序的是**回溯法**
49.9、10000*n^2+10*n+1的时间复杂度是**O（n^2）**。
三、简答题(2个小题，每小题5分，共10分）
1、简述分治法所能解决的问题一般具有的特征。
最优子结构性质和独立子问题

2、简述回溯法与分支限界法的异同。
**相同：分支限界法类似回溯法，也是在问题的解空间上搜索问题解的算法**
**不同：
+ **分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出解空间中满足约束条件的所有解，而分支限界法的求解目标是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。**
+ **分支限界法和回溯法的搜索方式也不同，回溯法以深度优先搜索的方式搜索解空间，分支限界法以广度优先或最小耗费优先的方式搜索解空间**


3、简述利用回溯法解决问题的一般步骤。
+ **针对所给问题，定义问题的解空间**
+ **确定易于搜索的解空间结构**
+ **以深度优先的方式搜索解空间**
+ **回溯法搜遍整个解空间，最后得到最优解**

4、动态规划算法的基本思想是什么？请简述动态规划算法主要设计步骤。
+ **基本思想：将待求解问题分解成若干子问题，先求解子问题，再结合这些子问题的解得到原答案的解**
+ **主要设计步骤：**
+ + **找出最优解的性质，并刻画其结构特征**
+ + **递归地定义最优值**
+ + **以自底向上的方式计算最优值**
+ + **根据计算最优值时得到的信息，构造最优解**

5、简述分治法的基本步骤。
**基本步骤：**
+ **分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题**
+ **解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题**
+ **合并：将各个子问题地解合并为原问题的解**

6、比较贪心算法与动态规划算法的异同，它们都有那些优势和劣势？
**相同点：贪心算法和动态规划算法都要求问题具有最优子结构性质**
**不同点：在动态规划中每步所做的选择往往依赖于相关子问题的解。而在贪心算法中仅在当前状态下做出最好选择，即局部最优选择，再去解做出这个选择后产生的相应的子问题。贪心算法所作的贪心选择可以依赖以往所作过的选择，但绝不依赖将来所作的选择，也不依赖子问题的解。**

**优势劣势：。。。。。。……再说吧**

8、简述分治法所能解决的问题一般具有的特征。
+ **该问题的规模缩小到一定的程度就可以容易的解决。**
+ **该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。**
+ **利用该问题分解出的子问题的解可以合并为该问题的解。**
+ **该问题所分解出的自问题是相互独立的，即子问题之间不包含子子问题。**



 四、应用题（1个小题，共10分）
1从A 地到D 地要铺设一条煤气管道,其中需经过两级中间站，两点之间的连线上的数字表示距离，如下图所示。问应该选择什么路线，使总距离最短？写出动态规划算法的向前递推（从最小规模开始）过程，并计算最优值及构造最优解。
![应用题1](images/应用题1.png )

(https://blog.csdn.net/HanTangSongMing/article/details/111359820 "问题类似')

**选择A->B1->C1->D路线总距离只有6 总距离最短**



2.使用回溯法解0/1背包问题：n=3，C=9，V={6,10,3}，W={3,4,4},其解空间有长度为3的0-1向量组成，要求用一棵完全二叉树表示其解空间（从根出发，左1右0），并画出其解空间树，计算其最优值及最优解。  

(https://blog.csdn.net/Jayphone17/article/details/104127385)






3.用动态规划策略求解最长公共子序列问题：
（1）给出计算最优值的递归方程。（4分）
（2）给定两个序列X={B,A,B,A}，Y={A,B,C,B}，请采用动态规划策略求出其最长公共子序列，要求给出过程（画出求解表格）。（4分） 
(https://blog.csdn.net/weixin_40673608/article/details/84262695)



4.某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。 但是这种导弹拦截系统 有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高 于前一发的高度。 某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。现输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹及拦截的各导弹高度是多少，并写出推导过程。输入：389  154  155  302  299  170  158  65  320  296  111  222  555  68  189
(https://blog.csdn.net/u013178472/article/details/54926531)





五、算法实现题(4个小题，每小题10分，共40分）
注：在对算法实现时，编程语言不限，各算法需要用子函数实现，并在main函数中测试。
1.把一个字符串（数组）进行逆序操作，如“abc"逆序为“cba” ，要求空间复杂度为O(1)。函数原型为：void  reverseString(char* str); 

```c++

 void reverseString(vector<char>& s) {
        int n = s.size();
        for(int i = 0, j = n-1;i<=j; i++,j--){
            char ch = s[i];
            s[i] = s[j];
            s[j] = ch;
        }

    
    }

```





2.已知某数列符合规则：f(n)=f(n-1)+f(n-2)+f(n-3),且n为自然数，f(1)=1,f(2)=1，f(3)=1,那么请求第n个数是多少。要求时间复杂度为O(n)，空间复杂度为O(1). 

```c++
    void f(int n) {
    int a = 1;
    int b = 1;
    int c = 1;
    int m;
    for (int i = 4; i <= n; i++) {
        m = a + b + c;
        a = b;
        b = c;
        c = m;
    }
    cout << m;
}

```

3.最小子段和问题：给出一个序列，其子段为该序列的一个连续的区间。例如：(1 -1 2 2 -3 -3 2 -4) ，( -3 -3 2 -4)为他的一个子段。给出一个序列，求出数字求和最小的一个子段。例如上面的序列， (-3 -3 2 -4)就是一个最小的子段，数字的总和为-8。
```c++
void solution(int *arr, int n) {
    int sum = 0;
    int ans = 0;
    int q[100];
    int r = 0;
    memset(q, 0x0, sizeof(q));
    for (int i = 1; i < n; i++) {
        if (q[i - 1] >= 0)
            q[i] = arr[i];
        else
            q[i] = q[i - 1] + arr[i];
        if (q[i] < ans) {
            ans = q[i];
            r = i;
        }
    }
    cout << ans << endl;
    int temp = 0;
    int l = 0;
    for (int j = r; j >= 0; j--) {
        temp += arr[j];
        if (temp == ans) {
            l = j;
            break;
        }
    }
    for (int j = l; j <= r; j++) {
        cout << arr[j] << " ";
    }
}
```

4.键盘输入n个正整数（互不相等），找出其中和等于m的所有组合。输出顺序不限
【输入样例】输入：5（m的值） 1 2 3 4 5（n个正整数） 
【输出样例】：1  4 
            2  3 
             5 

```c++
#include <bits/stdc++.h>
using namespace std;
int n;
int m;
int arr[100];
int book[100];
void dfs(int t, int sum, int idx) {
    if (sum > m) return;
    if (sum == m) {
        for (int i = 0; i < t; i++) {
            cout << book[i] << " ";
        }
        cout << endl;
    }
    for (int i = idx; i < n; i++) {
        book[t] = arr[i];
        dfs(t + 1, sum + arr[i], i + 1);
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> arr[i];
    dfs(0, 0, 0);
}

```

5.使用递归算法对一个整数进行逆序转换，如1234逆序为4321。顶层函数原型为：
   int reverseInteger(int a); 在具体实现时可增加子函数。 

```c++
int reverseInteger(int x) {
        long long ans=0;
        int t = 1;
        long long p = 1;
        if(x<0){
            t = -1;
            x = abs(x);
        }
        while(x>0){
            int temp = x%10;
            ans = p*ans+temp;
            p=10;
            x/=10;
        }
        return t*ans;
    }
```


6.已知某数列符合规则：f(n)=2*f(n-1)+3*f(n-2)+f(n-3),且n为自然数，f(1)=1,f(2)=1，f(3)=1,那么请求第n个数是多少。要求时间复杂度为O(n)，空间复杂度为O(1). 


```c++
    void f(int n) {
    int a = 1;
    int b = 1;
    int c = 1;
    int m;
    for (int i = 4; i <= n; i++) {
        m = a + 3*b + 2*c;
        a = b;
        b = c;
        c = m;
    }
    cout << m;
}

```




7.最大子段和问题：给出一个序列，其子段为该序列的一个连续的区间。例如：(1 -1 2 2 3 -3 4 -4) ，(2 2 3 -3 4)为他的一个子段。给出一个序列，求出数字求和最大的一个子段。例如上面的序列， (2 2 3 -3 4)就是一个最大的子段，数字的总和为8。

```c++
void solution(int *arr, int n) {
    int sum = 0;
    int ans = 0;
    int q[100];
    int r = 0;
    memset(q, 0x0, sizeof(q));
    for (int i = 1; i < n; i++) {
        if (q[i - 1] < 0)
            q[i] = arr[i];
        else
            q[i] = q[i - 1] + arr[i];
        if (q[i] > ans) {
            ans = q[i];
            r = i;
        }
    }
    cout << ans << endl;
    int temp = 0;
    int l = 0;
    for (int j = r; j >= 0; j--) {
        temp += arr[j];
        if (temp == ans) {
            l = j;
            break;
        }
    }
    for (int j = l; j <= r; j++) {
        cout << arr[j] << " ";
    }
}
```

8.键盘输入n个正整数（互不相等），找出其中和大于m的所有组合。输出顺序不限
【输入样例】输入：5（m的值） 1 2 3 4 5（n个正整数） 
【部分输出样例】：1  5 
                2  4 
                    3  5

```c++
#include <bits/stdc++.h>
using namespace std;
int n;
int m;
int arr[100];
int book[100];
void dfs(int t, int sum, int idx) {
    if (sum > m) {
        for (int i = 0; i < t; i++) {
            cout << book[i] << " ";
        }
        cout << endl;
    }
    for (int i = idx; i < n; i++) {
        book[t] = arr[i];
        dfs(t + 1, sum + arr[i], i + 1);
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> arr[i];
    dfs(0, 0, 0);
}
```

9.超级楼梯问题：有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级h或三级，要走上第M级，共有多少种走法？要求时间复杂度为O(n)，空间复杂度为O(1)。


```c++
    void f(int n) {
    int a = 1;
    int b = 1;
    int c = 1;
    int m;
    for (int i = 4; i <= n; i++) {
        m = a + b + c;
        a = b;
        b = c;
        c = m;
    }
    cout << m;
}

```

10请用递归算法判断一个整数数组是否是对称的，比如数组为{1,2,2,1}就是对称的。要求递归函数返回bool类型。

```c++
bool solution(int *arr, int l, int r) {
    if (l >= r) return true;
    if (arr[l] == arr[r]) {
        solution(arr, l + 1, r - 1);
    } else {
        return false;
    }
}
```





12将正整数n表示成一系列正整数之和：n=n1+n2+…+nk，其中n1≥n2≥…≥nk≥1，k≥1。正整数n的这种表示称为正整数n的划分。输出正整数n的不同划分个数及具体的划分形式。
例如正整数6有如下11种不同的划分：   
6；   
5+1；    
4+2，4+1+1；   
3+3，3+2+1，3+1+1+1；
2+2+2，2+2+1+1，2+1+1+1+1；   
1+1+1+1+1+1

```c++
#include <bits/stdc++.h>
using namespace std;
int dp[100];
int arr[100];
int n;
vector<int> v;
int split(int n, int m) {
    if (n == 1 || m == 1)
        return 1;
    else if (n < m)
        return split(n, n);
    else if (n == m)
        return split(n, n - 1) + 1;
    else
        return split(n, m - 1) + split(n - m, m);
}

void solution(int sum, int t, int idx) {
    if (sum > n) return;
    if (sum == n) {
        cout << n << "=";
        for (int i = 0; i < t - 1; i++) cout << arr[i] << "+";
        cout << arr[t - 1] << endl;
    } else {
        for (int i = idx; i > 0; i--) {
            arr[t] = i;
            solution(sum + i, t + 1, i);
        }
    }
}

int main() {
    cin >> n;
    solution(0, 0, n);
}
```

13请用分支限界法实现：
八皇后问题：在8×8的国际象棋盘上，放置八个皇后，使任何一个皇后都不能吃掉另一个
国际象棋规则中，皇后可以吃到任何一个与他在同一行、同一列或者同一斜线上的敌方棋子，所以八皇后问题的所有解满足：
8个皇后都不在同一行、同一列，或者同一斜线上；或者任意行、列或者斜线上 有且仅有一个皇后。



14给定一个高度为 n 的“数字三角形”，其中第 i 行（1<=i<=n）有 i 个数。（例子如下图所示） 
1 
2  3
4  5  6
7  8  9  10
初始时，你站在“数字三角形”的顶部，即第一行的唯一一个数上。每次移动，你可以选择移动到当前位置正下方或者当前位置右下方的位置上。即如果你在 (i,j)（表示你在第i行从左往右数第j个数上，下同），你可以选择移动到 (i+1,j) 或 (i+1,j+1)。
你想让你经过的所有位置（包括起点和终点）的数字总和最大。求这个最大值。
 ```c++
 int n;
    int arr[105][105];
    int dp[105][105];
    triangleNum() {
        cin >> n;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++)
                cin >> arr[i][j];
        }
    }
    void getMaxNum() {
        for (int i = n - 1; i >= 0; i--) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = max(dp[i + 1][j], dp[i + 1][j + 1]) + arr[i][j];
            }
        }
        cout << dp[0][0];
    }
 ```


15用回溯法解决：给定n个正整数wi和一个正整数m，在这n个正整数中找出一个子集，使得子集中的正整数之和等于m。

```c++
#include <bits/stdc++.h>
using namespace std;
int n;
int m;
int arr[100];
int book[100];
void dfs(int t, int sum, int idx) {
    if (sum > m) return;
    if (sum == m) {
        for (int i = 0; i < t; i++) {
            cout << book[i] << " ";
        }
        cout << endl;
    }
    for (int i = idx; i < n; i++) {
        book[t] = arr[i];
        dfs(t + 1, sum + arr[i], i+1);
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> arr[i];
    dfs(0, 0, 0);
}
```

16给定一个存放整数的数组，重新排列数组使得数组左边为偶数，右边为奇数。
如对数组：1,2,3,4,5,6,7,8,9处理后，该数组变为：2,4,6,8,1,3,5,7,9。 

```c++
#include <bits/stdc++.h>
using namespace std;
int dp[100];
int arr[100];
int book[100];
int n;
int m;

vector<int> v;
void solution() {
    for (int i = 0, j = n - 1; i < j;) {
        while (arr[i] % 2 == 0) i++;
        while (arr[j] % 2 == 1) j--;
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        i++;
        j--;
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> arr[i];
    solution();
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
}

```

17编写函数double getRestul(int n)并测试，它的功能是：根据以下公式计算结果S。

![算法题17](images/算法题17.png)

```c++

#include <bits/stdc++.h>
using namespace std;
int dp[100];
int arr[100];
int book[100];
int n;
int m;

vector<int> v;
double getRestul(int n) {
    double sum;
    double t = 1;
    for (int i = 1, j = 0; i <= 2 * n; j++, i += 2) {
        if (j % 2 == 0)
            t = 1.0;
        else
            t = -1.0;
        sum += t * (1.0 / i);
    }
    return sum;
}
int main() {
    cin >> n;
    printf("%lf", getRestul(n));
}


```





